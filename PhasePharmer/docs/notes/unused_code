
            let dDiff = rdyDay - getUTCNow().getUTCDate();
            let hDiff = rdyHour - getUTCNow().getUTCHours();
            let mDiff = rdyMin - getUTCNow().getUTCMinutes();
            let sDiff = rdySec - getUTCNow().getUTCSeconds();
            while (dDiff) {
                dDiff -= 1;
                hDiff += 24;
            }
            if (hDiff < 0) {
                dDiff -= 1;
                hDiff += 24;
            }
            if (mDiff < 0) {
                hDiff -= 1;
                mDiff += 60;
            }
            if (sDiff < 0) {
                mDiff -= 1;
                sDiff += 60;
            }



function curMoonFrac_old(JD) {
    let t = (JD - 2451545) / 36525;
    let t2 = mF.p(t, 2);
    let t3 = mF.p(t, 3);
    let t4 = mF.p(t, 4);
    let sunGML = 280.46646 + (36000.76983 * t) + (0.0003032 * t2);
    let meanAnom = 357.52911 + (35999.05029 * t) - (0.0001537 * t2);
    let meanAnom2 = meanAnom * 2;
    let meanAnom3 = meanAnom * 3;
    let orbEccnt = 0.016708634 - (0.000042037 * t) - (0.0000001267 * t2);
    let sunCent = ((1.914602 - (0.004817 * t) - (0.000014 * t2)) * mF.s(meanAnom))
        + (0.019993 - (0.000101 * t) * mF.s(meanAnom2)) + (0.000289 * mF.s(meanAnom3));
    let eclpOblq = 23.439291111111 - (0.0130041666667 * t) - (0.00059 * t2 / 3600) + (0.001813 * t3 / 3600);
    let sunLong = sunGML + sunCent;
    let sunAsc = mF.at(mF.c(eclpOblq) * mF.s(sunLong)) / mF.c(sunLong);
    let sunDec = mF.as(mF.s(eclpOblq) * mF.s(sunLong));
    let sunAnom = meanAnom + sunCent;

    let argL = 218.3164477 + (481267.88123421 * t) - (0.0015786 * t2) + (t3 / 538841) - (t4 / 65194000);
    let argD = 297.8501921 + (445267.1114034 * t) - (0.0018819 * t2) + (t3 / 545868) - (t4 / 113065000);
    let argMs = 357.5291092 + (35999.0502909 * t) - (0.0001536 * t2) + (t3 / 24490000);
    let argMm = 134.9633964 + (477198.8675055 * t) + (0.0087414 * t2) + (t3 / 69699) - (t4 / 14712000);
    let argF = 93.2720950 + (483202.0175233 * t) - (0.0036539 * t2) - (t3 / 3526000) + (t4 / 863310000);
    let argE = 1 - (0.002516 * t) - (0.0000074 * t2);
    let arg1 = mF.dTR(119.75) + (mF.dTR(131.849) * t);
    let arg2 = mF.dTR(53.09) + (mF.dTR(mF.rA(479264.290) * t));
    let arg3 = mF.dTR(313.45) + (mF.dTR(mF.rA(481266.484) * t));
    let sigL = 0;
    let sigR = 0;
    let sigB = 0;
    let aDL = argDistLong;
    let aL = argLat;

    for (let i = 0; i < aDL.length; i++) {
        if ((aDL[i][1] === 1) || (aDL[i][1] === -1)) {
            sigL += (aDL[i][4] * argE)
                * mF.s(
                    (aDL[i][0] * argD)
                    + (aDL[i][1] * argMs)
                    + (aDL[i][2] * argMm)
                    + (aDL[i][3] * argF)
                );

            sigR += (aDL[i][5] * argE)
                * (mF.c(
                        (aDL[i][0] * argD)
                        + (aDL[i][1] * argMs)
                        + (aDL[i][2] * argMm)
                        + (aDL[i][3] * argF)
                    )
                );
        }
        else if ((aDL[i][1] === 2) || (aDL[i][1] === -2)) {
            sigL += (aDL[i][4] * mF.p(argE, 2))
                * (mF.s(
                        (aDL[i][0] * argD)
                        + (aDL[i][1] * argMs)
                        + (aDL[i][2] * argMm)
                        + (aDL[i][3] * argF))
                );

            sigR += (aDL[i][5] * mF.p(argE, 2))
                * (mF.c(
                        (aDL[i][0] * argD)
                        + (aDL[i][1] * argMs)
                        + (aDL[i][2] * argMm)
                        + (aDL[i][3] * argF))
                );
        }
        else {
            sigL += aDL[i][4]
                * (mF.s(
                        (aDL[i][0] * argD)
                        + (aDL[i][1] * argMs)
                        + (aDL[i][2] * argMm)
                        + (aDL[i][3] * argF))
                );

            sigR += aDL[i][5]
                * (mF.c(
                        (aDL[i][0] * argD)
                        + (aDL[i][1] * argMs)
                        + (aDL[i][2] * argMm)
                        + (aDL[i][3] * argF))
                );
        }
    }

    for (let i = 0; i < aL.length; i++) {
        if ((aL[i][1] === 1) || (aL[i][1] === -1)) {
            sigB += (aL[i][4] * argE)
                * (mF.s(
                        (aL[i][0] * argD)
                        + (aL[i][1] * argMs)
                        + (aL[i][2] * argMm)
                        + (aL[i][3] * argF))
                );
        }
        else if ((aL[i][1] === 2) || (aL[i][1] === -2)) {
            sigB += (aL[i][4] * mF.p(argE, 2))
                * (mF.s(
                    (aL[i][0] * argD)
                    + (aL[i][1] * argMs)
                    + (aL[i][2] * argMm)
                    + (aL[i][3] * argF)));
        }
        else {
            sigB += aL[i][4]
                * (mF.s(
                        (aL[i][0] * argD)
                        + (aL[i][1] * argMs)
                        + (aL[i][2] * argMm)
                        + (aL[i][3] * argF))
                );
        }
    }

    sigL += (3958 * mF.s(arg1))
        + (1962 * mF.s(argL - argF))
        + (318 * mF.s(arg2));

    sigB += (-2235 * mF.s(argL))
        + (382 * mF.s(arg3))
        + (175 * mF.s(arg1 - argF))
        + (175 * mF.s(arg1 + argF))
        + (127 * mF.s(argL - argMm))
        - (115 * mF.s(argL + argMm));

    let moonGeoLong = argL + (sigL / 1000000);
    let moonGeoLat = sigB / 1000000;
    let moonEarthDist = 385000.56 + (sigR / 1000);

    let moonGeoElg = mF.ac(mF.c(argF) * mF.c(argL - sunLong));

    let sunDist = (1.000001018 * (1 - mF.p(orbEccnt, 2))) / (1 + (orbEccnt * mF.c(sunAnom)));

    let moonPhsAng = mF.at(
        (sunDist * mF.s(moonGeoElg))
        / (moonEarthDist - (sunDist * mF.c(moonGeoElg)))
    );

    return ((1 + mF.c(moonPhsAng)) / 2);
}
